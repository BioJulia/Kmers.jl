var documenterSearchIndex = {"docs":
[{"location":"replacements/","page":"K-mer replacements","title":"K-mer replacements","text":"CurrentModule = Kmers\nDocTestSetup = quote\n    using BioSequences\n    using Test\n    using Kmers\n    using Random\nend","category":"page"},{"location":"replacements/#replacements","page":"K-mer replacements","title":"Building kmer replacements","text":"","category":"section"},{"location":"replacements/","page":"K-mer replacements","title":"K-mer replacements","text":"Kmer replacements is the general term for sequences that can be represented computationally like kmers, but are sampled differently. Examples include minimizers, strobemers, syncmers and k-min-mers.","category":"page"},{"location":"replacements/","page":"K-mer replacements","title":"K-mer replacements","text":"Since there is no end to the variations of kmer replacements, Kmers.jl does not try to implement all of them. Instead, Kmers.jl implements the base kmer type, and exposes some efficient primitives to allow downstream users to build kmer replacements.","category":"page"},{"location":"replacements/","page":"K-mer replacements","title":"K-mer replacements","text":"These functions are:","category":"page"},{"location":"replacements/","page":"K-mer replacements","title":"K-mer replacements","text":"unsafe_extract\nshift_encoding\nunsafe_shift_from","category":"page"},{"location":"replacements/#Kmers.unsafe_extract","page":"K-mer replacements","title":"Kmers.unsafe_extract","text":"unsafe_extract(::RecodingScheme, T::Type{<:Kmer}, seq, from::Int) -> T\n\nExtract a Kmer of type T from seq beginning at index from. This function is useful to create kmer or kmer-like types.\n\nThis function does not do any bounds checking, so the user must know that from:from+K-1 is inbounds in seq. The validity of the data in the seq is validated by this function.\n\nExamples\n\njulia> seq = b\"TAGCTAGA\";\n\njulia> Kmers.unsafe_extract(Kmers.AsciiEncode(), DNAKmer{4, 1}, seq, 2)\nDNA 4-mer:\nAGCT\n\n\n\n\n\n","category":"function"},{"location":"replacements/#Kmers.shift_encoding","page":"K-mer replacements","title":"Kmers.shift_encoding","text":"shift_encoding(kmer::T, encoding::UInt) where {T <: Kmer} -> T\n\nAdd encoding, a valid encoding in the alphabet of the kmer, to the end of kmer and discarding the first symbol in kmer.\n\nIt is the user's responsibility to ensure that encoding is valid.\n\nExamples\n\njulia> enc = UInt(0x0a); # encoding of DNA_Y in 4-bit alphabets\n\njulia> kmer = Kmer{DNAAlphabet{4}, 4}(\"TAGA\");\n\njulia> Kmers.shift_encoding(kmer, enc)\nDNA 4-mer:\nAGAY\n\n\n\n\n\n","category":"function"},{"location":"replacements/#Kmers.unsafe_shift_from","page":"K-mer replacements","title":"Kmers.unsafe_shift_from","text":"unsafe_shift_from(::RecodingScheme, kmer::T, seq, from::Int, ::Val{S}) -> T\n\nExtract S::Int symbols from sequence seq at positions from:from+S-1, and shift them into kmer.\n\nThis function does not do any bounds checking, so it is the user's responsibility to ensure that from is inbounds, and the recoding scheme valid. It is assumed that S < K, where K == length(kmer). If S ≥ K, use unsafe_extract instead.\n\nExamples\n\njulia> seq = dna\"TAGCGGA\";\n\njulia> kmer = mer\"GGTG\"d;\n\njulia> Kmers.unsafe_shift_from(Kmers.FourToTwo(), kmer, seq, 3, Val(2))\nDNA 4-mer:\nTGGC\n\n\n\n\n\n","category":"function"},{"location":"replacements/#Example:-Minimizers","page":"K-mer replacements","title":"Example: Minimizers","text":"","category":"section"},{"location":"replacements/","page":"K-mer replacements","title":"K-mer replacements","text":"Minimizers are currently the most common kmer replacement. They are defined as the minimum of W consecutive kmers, as ordered by some ordering O.","category":"page"},{"location":"replacements/","page":"K-mer replacements","title":"K-mer replacements","text":"If we use fx_hash as the ordering function, and assume K and W are known at compile time, we can implement it reasonably efficiently like so:","category":"page"},{"location":"replacements/","page":"K-mer replacements","title":"K-mer replacements","text":"function unsafe_extract_minimizer(\n    seq::LongDNA{2},\n    i::Int,\n    ::Val{K},\n    ::Val{W},\n) where {K, W}\n    T = derive_type(Kmer{DNAAlphabet{2}, K})\n    kmer = Kmers.unsafe_extract(Kmers.Copyable(), T, seq, i)\n    hash = fx_hash(kmer)\n    for offset in 0:W-2\n        new_kmer = Kmers.unsafe_shift_from(Kmers.Copyable(), kmer, seq, i+K+offset, Val(1))\n        new_hash = fx_hash(new_kmer)\n        if new_hash < hash\n            hash = new_hash\n            kmer = new_kmer\n        end\n    end\n    kmer\nend\n\nrng = Random.Xoshiro(1)\nunsafe_extract_minimizer(randseq(rng, DNAAlphabet{2}(), 100), 1, Val(5), Val(9))\n\n# output\nDNA 5-mer:\nTATCA","category":"page"},{"location":"minhash/","page":"MinHash","title":"MinHash","text":"CurrentModule = Kmers\nDocTestSetup = quote\n    using BioSequences\n    using Test\n    using Kmers\n    using FASTX\n    using MinHash\nend","category":"page"},{"location":"minhash/#MinHash","page":"MinHash","title":"MinHash","text":"","category":"section"},{"location":"minhash/","page":"MinHash","title":"MinHash","text":"The MinHash algorithm is used in tools such as Mash and sourmash to quickly compute approximate similarities of genomes, collections of genomes, or collections of reads.","category":"page"},{"location":"minhash/","page":"MinHash","title":"MinHash","text":"using BioSequences, MinHash, FASTX, Kmers\n\n# Write 25 sequences of length 20 to a buffer.\n# Try changing this to length 4 million!\nbuffer = IOBuffer()\nwriter = FASTAWriter(buffer)\nn_bytes = sum(1:25) do genome\n    rec = FASTARecord(\"seq_$(genome)\", randdnaseq(20))\n    write(writer, rec)\nend\nflush(writer)\n\n# Time minhashing the 50 genomes\ntiming = @timed FASTAReader(seekstart(buffer); copy=false) do reader\n    map(reader) do record\n        seq = codeunits(sequence(record))\n        sketch(fx_hash, CanonicalDNAMers{16}(sequence(record)), 1000)\n    end\nend\nprintln(round(Int, n_bytes / (timing.time * 1e6)), \" MB/s\")\n\n# output\n\n200 MB/s","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"CurrentModule = Kmers\nDocTestSetup = quote\n    using BioSequences\n    using Test\n    using Kmers\nend","category":"page"},{"location":"kmers/#The-Kmer-type","page":"The Kmer type","title":"The Kmer type","text":"","category":"section"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"The central type of Kmers.jl is the Kmer. A Kmer is an immutable, bitstype BioSequence, with a length known at compile time. Compared to LongSequence in BioSequences.jl, this gives to one advantage, and comes with two disadvantages:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"Kmers are much faster than LongSequence, as they can be stored in registers.\nAs kmers gets longer, the code gets increasingly inefficient, as the unrolling and inlining of the immutable operations breaks down.\nSince their length is part of their type, any operation that results in a kmer whose length cannot be determined at compile time will be type unstable. This includes slicing a kmer, pushing and popping it, and other operations.","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"The Kmer type is (roughly) defined as","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"struct Kmer{A <: Alphabet, K, N} <: BioSequence{A}\n    x::NTuple{N, UInt}\nend","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"Where:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"A is the Alphabet as defined in BioSequences.jl.\nK is the length.\nN is an extra type parameter derived from the first two used for the length of the tuple, which exists only because Julia does not allow computed type parameters.","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"Given a Kmer{A, K}, the N parameter may be computed using the function derive_type:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"julia> derive_type(Kmer{AminoAcidAlphabet, 6})\nKmer{AminoAcidAlphabet, 6, 1}","category":"page"},{"location":"kmers/#Construction","page":"The Kmer type","title":"Construction","text":"","category":"section"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"Kmers can be constructed from a BioSequence or AbstractString by explicitly specifying the length of the sequence:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"julia> Kmer{DNAAlphabet{2}, 5, 1}(\"TAGCT\")\nDNA 5-mer:\nTAGCT","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"The final type parameter N can be elided, in which case it will be inferred:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"julia> Kmer{DNAAlphabet{2}, 5}(\"TAGCT\")\nDNA 5-mer:\nTAGCT","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"Kmers with alphabets DNAAlphabet{2}, RNAAlphabet{2} and AminoAcidAlphabet can be created with the type aliases DNAKmer, RNAKmer and AAKmer:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"julia> DNAKmer{3}(\"tag\")\nDNA 3-mer:\nTAG\n\njulia> AAKmer{5}(\"PWYSK\")\nAminoAcid 5-mer:\nPWYSK","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"For kmers with an Alphabet that implement the trait BioSequences.AsciiAlphabet, they can also be constructed from AbstractVector{UInt8}, in which case the vector is interpreted as being bytes of ASCII text:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"julia> AAKmer{3}([0x65, 0x67, 0x7a])\nAminoAcid 3-mer:\nEGZ","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"When constructing from an AbstractString (or byte vector), uracil (U) and thymine T are treated differently - a U cannot be read as thymine:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"julia> DNAKmer{3}(\"UAG\")\nERROR: cannot encode 0x55 (Char 'U') in DNAAlphabet{2}\n[...]","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"However, when constructing from a BioSequence, these nucleotides are considered interchangeable:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"julia> RNAKmer{4}(dna\"TATC\")\nRNA 4-mer:\nUAUC","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"Finally, kmers can be constructed with a string literal @mer_str, where the string must be appended with d for DNA, r for RNA, or a for amino acid:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"julia> mer\"UGCUGA\"r\nRNA 6-mer:\nUGCUGA\n\njulia> mer\"EDEHL\"a\nAminoAcid 5-mer:\nEDEHL","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"Since the literals produce the kmer at parse time and inserts the kmer directly into the abstract syntax tree, this will always be type stable, and the overhead related to parsing the string will not be paid.","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"In the following example, each iteration takes less than 1 nanosecond, which implies that parsing the string literal mer\"AAA\"d is not done in the loop at runtime:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"julia> function count_aaas(dna)\n           x = 0\n           for kmer in FwDNAMers{3}(dna)\n               # The parsing happens once here, when the\n               # code is parsed, and is fine to have in the loop\n               x += kmer == mer\"AAA\"d\n           end\n           x\n       end;\n\njulia> seq = randseq(DNAAlphabet{2}(), 100_000_000);\n\njulia> count_aaas(seq); # compile\n\njulia> @time count_aaas(seq) # about 1ns per iteration\n  0.088556 seconds (1 allocation: 16 bytes)\n1561361","category":"page"},{"location":"kmers/#Indexing","page":"The Kmer type","title":"Indexing","text":"","category":"section"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"Kmers support most normal indexing, such as scalar indexing:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"julia> mer\"CAGCU\"r[3]\nRNA_G","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"Slicing","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"julia> mer\"AGGCTA\"d[2:5]\nDNA 4-mer:\nGGCT","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"And indexing with boolean vectors, and vectors of indices:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"julia> m = mer\"MDGKRY\"a;\n\njulia> m[[true, false, true, true, false, true]]\nAminoAcid 4-mer:\nMGKY\n\njulia> m[[4,2]]\nAminoAcid 2-mer:\nKD","category":"page"},{"location":"kmers/#A-note-on-type-stability","page":"The Kmer type","title":"A note on type stability","text":"","category":"section"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"Except scalar indexing which always returns a single symbol, all the operations above are type unstable, since the length (and thus type) of the resulting  kmer depends on the input value, not its type.","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"However, type unstable functions may be type-stable, if the indexing value is known at compile time, and the Julia compiler uses constant folding:","category":"page"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"julia> f(x) = x[2:5]; # 2:5 is a compile time constant\n\njulia> Test.@inferred f(mer\"UCGUAGC\"r)\nRNA 4-mer:\nCGUA","category":"page"},{"location":"kmers/#Reference","page":"The Kmer type","title":"Reference","text":"","category":"section"},{"location":"kmers/","page":"The Kmer type","title":"The Kmer type","text":"Kmer\nderive_type\nMer\n@mer_str\nDNAKmer\nRNAKmer\nAAKmer\nDNACodon\nRNACodon\npop\npop_first\npush\npush_first\nshift\nshift_first","category":"page"},{"location":"kmers/#Kmers.Kmer","page":"The Kmer type","title":"Kmers.Kmer","text":"Kmer{A<:Alphabet,K,N} <: BioSequence{A}\n\nAn immutable bitstype for representing k-mers - short BioSequences of a fixed length K. Since they can be stored directly in registers, Kmers are generally the most efficient type of BioSequence, when K is small and known at compile time.\n\nThe N parameter is derived from A and K and is not a free parameter.\n\nSee also: DNAKmer, RNAKmer, AAKmer, AbstractKmerIterator\n\nExamples\n\njulia> RNAKmer{5}(\"ACGUC\")\nRNA 5-mer:\nACGUC\n\njulia> Kmer{DNAAlphabet{4}, 6}(dna\"TGCTTA\")\nDNA 6-mer:\nTGCTTA\n\njulia> AAKmer{5}((lowercase(i) for i in \"KLWYR\"))\nAminoAcid 5-mer:\nKLWYR\n\njulia> RNAKmer{3}(\"UAUC\") # wrong length\nERROR:\n[...]\n\n\n\n\n\n","category":"type"},{"location":"kmers/#Kmers.derive_type","page":"The Kmer type","title":"Kmers.derive_type","text":"derive_type(::Type{Kmer{A, K}}) -> Type{Kmer{A, K, N}}\n\nCompute the fully parameterized kmer type from only the parameters A and K.\n\n\n\n\n\n","category":"function"},{"location":"kmers/#Kmers.Mer","page":"The Kmer type","title":"Kmers.Mer","text":"Mer{K}\n\nAlias for Kmer{<:Alphabet, K}. Useful to dispatch on K-mers without regard for the alphabat\n\nExample\n\njulia> mer\"DEKR\"a isa Mer{4}\ntrue\n\njulia> DNAKmer{6}(\"TGATCA\") isa Mer{6}\ntrue\n\njulia> RNACodon <: Mer{3}\ntrue\n\n\n\n\n\n","category":"type"},{"location":"kmers/#Kmers.@mer_str","page":"The Kmer type","title":"Kmers.@mer_str","text":"@mer_str -> Kmer\n\nConstruct a Kmer from the given string. The macro must be used with a flag after the input string, e.g. d in mer\"TAG\"d or a in mer\"PCW\"a, signifying the alphabet of the kmer. The flags d = DNAAlphabet{2}, r = RNAAlphabet{2} and a = AminoAcidAlphabet are recognized.\n\nBecause the macro is resolved and the kmer is created at parse time, the macro is type stable, and may be used in high performance code.\n\nExamples\n\njulia> mer\"UGCUA\"r\nRNA 5-mer:\nUGCUA\n\njulia> mer\"YKVSTEDLLKKR\"a\nAminoAcid 12-mer:\nYKVSTEDLLKKR\n\njulia> mer\"TATTAGCA\"d\nDNA 8-mer:\nTATTAGCA\n\n\n\n\n\n","category":"macro"},{"location":"kmers/#Kmers.DNAKmer","page":"The Kmer type","title":"Kmers.DNAKmer","text":"Alias for Kmer{DNAAlphabet{2},K,N}\n\n\n\n\n\n","category":"type"},{"location":"kmers/#Kmers.RNAKmer","page":"The Kmer type","title":"Kmers.RNAKmer","text":"Alias for Kmer{RNAAlphabet{2},K,N}\n\n\n\n\n\n","category":"type"},{"location":"kmers/#Kmers.AAKmer","page":"The Kmer type","title":"Kmers.AAKmer","text":"Alias for Kmer{AminoAcidAlphabet,K,N}\n\n\n\n\n\n","category":"type"},{"location":"kmers/#Kmers.DNACodon","page":"The Kmer type","title":"Kmers.DNACodon","text":"Alias for DNAKmer{3,1}\n\n\n\n\n\n","category":"type"},{"location":"kmers/#Kmers.RNACodon","page":"The Kmer type","title":"Kmers.RNACodon","text":"Alias for RNAKmer{3,1}\n\n\n\n\n\n","category":"type"},{"location":"kmers/#Kmers.pop","page":"The Kmer type","title":"Kmers.pop","text":"pop(kmer::Kmer{A, K})::Kmer{A, K-1}\n\nReturns a new kmer with the last symbol of the input kmer removed. Throws an ArgumentError if kmer is empty.\n\nwarn: Warn\nSince the output of this function is a K-1-mer, use of this function in a loop may result in type-instability.\n\nSee also: pop_first, push, shift\n\nExamples\n\njulia> pop(mer\"TCTGTA\"d)\nDNA 5-mer:\nTCTGT\n\njulia> pop(mer\"QPSY\"a)\nAminoAcid 3-mer:\nQPS\n\njulia> pop(mer\"\"a)\nERROR: ArgumentError:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"kmers/#Kmers.pop_first","page":"The Kmer type","title":"Kmers.pop_first","text":"pop_first(kmer::Kmer{A, K})::Kmer{A, K-1}\n\nReturns a new kmer with the first symbol of the input kmer removed. Throws an ArgumentError if kmer is empty.\n\nwarn: Warn\nSince the output of this function is a K-1-mer, use of this function in a loop may result in type-instability.\n\nSee also: pop, push, shift\n\nExamples\n\njulia> pop_first(mer\"TCTGTA\"d)\nDNA 5-mer:\nCTGTA\n\njulia> pop_first(mer\"QPSY\"a)\nAminoAcid 3-mer:\nPSY\n\njulia> pop_first(mer\"\"a)\nERROR: ArgumentError:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"kmers/#Kmers.push","page":"The Kmer type","title":"Kmers.push","text":"push(kmer::Kmer{A, K}, s)::Kmer{A, K+1}\n\nCreate a new kmer which is the concatenation of kmer and s. Returns a K+1-mer.\n\nwarn: Warn\nSince the output of this function is a K+1-mer, use of this function in a loop may result in type-instability.\n\nSee also: push_first, pop, shift\n\nExamples\n\njulia> push(mer\"UGCUGA\"r, RNA_G)\nRNA 7-mer:\nUGCUGAG\n\njulia> push(mer\"W\"a, 'E')\nAminoAcid 2-mer:\nWE\n\n\n\n\n\n","category":"function"},{"location":"kmers/#Kmers.push_first","page":"The Kmer type","title":"Kmers.push_first","text":"push_first(kmer::Kmer{A, K}, s)::Kmer{A, K+1}\n\nCreate a new kmer which is the concatenation of s and kmer. Returns a K+1-mer. Similar to push, but places the new symbol s at the front.\n\nwarn: Warn\nSince the output of this function is a K+1-mer, use of this function in a loop may result in type-instability.\n\nSee also: push,  pop, shift\n\nExamples\n\njulia> push_first(mer\"GCU\"r, RNA_G)\nRNA 4-mer:\nGGCU\n\njulia> push_first(mer\"W\"a, 'E')\nAminoAcid 2-mer:\nEW\n\n\n\n\n\n","category":"function"},{"location":"kmers/#Kmers.shift","page":"The Kmer type","title":"Kmers.shift","text":"shift(kmer::Kmer{A, K}, s)::Kmer{A, K}\n\nPush symbol onto the end of kmer, and pop the first symbol in kmer. Unlike push, this preserves the input type, and is less likely to result in type instability.\n\nSee also: shift_first, push\n\nExamples\n\njulia> shift(mer\"TACC\"d, DNA_A)\nDNA 4-mer:\nACCA\n\njulia> shift(mer\"WKYMLPIIRS\"aa, 'F')\nAminoAcid 10-mer:\nKYMLPIIRSF\n\n\n\n\n\n","category":"function"},{"location":"kmers/#Kmers.shift_first","page":"The Kmer type","title":"Kmers.shift_first","text":"shift_first(kmer::kmer, symbol)::typeof(kmer)\n\nPush symbol onto the start of kmer, and pop the last symbol in kmer.\n\nSee also: shift, push\n\nExamples\n\njulia> shift_first(mer\"TACC\"d, DNA_A)\nDNA 4-mer:\nATAC\n\njulia> shift_first(mer\"WKYMLPIIRS\"aa, 'F')\nAminoAcid 10-mer:\nFWKYMLPIIR\n\n\n\n\n\n","category":"function"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"CurrentModule = Kmers\nDocTestSetup = quote\n    using BioSequences\n    using Test\n    using Kmers\nend","category":"page"},{"location":"iteration/#Iteration","page":"Iteration","title":"Iteration","text":"","category":"section"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"Most applications of kmers extract multiple kmers from an underlying sequence. To facilitate this, Kmers.jl implements a few basic kmer iterators, most of which are subtypes of AbstractKmerIterator.","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"The underlying sequence can be a BioSequence, AbstractString, or AbstractVector{UInt8}. In the latter case, if the alphabet of the element type implements BioSequences.AsciiAlphabet, the vector will be treated as a vector of ASCII characters.","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"Similarly to the rules when constructing kmers directly, DNA and RNA is treated interchangeably when the underlying sequence is a BioSequence, but when the underlying sequence is a string or bytevector, U and T are considered different, and e.g. uracil cannot be constructed from a sequence containing T:","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"julia> only(FwDNAMers{3}(rna\"UGU\"))\nDNA 3-mer:\nTGT\n\njulia> only(FwDNAMers{3}(\"UGU\"))\nERROR:\n[...]","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"The following kmer iterators are implemented:","category":"page"},{"location":"iteration/#FwKmers","page":"Iteration","title":"FwKmers","text":"","category":"section"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"The most basic kmer iterator is FwKmers, which simply iterates every kmer, in order:","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"FwKmers\nFwDNAMers\nFwRNAMers\nFwAAMers","category":"page"},{"location":"iteration/#Kmers.FwKmers","page":"Iteration","title":"Kmers.FwKmers","text":"FwKmers{A <: Alphabet, K, S} <: AbstractKmerIterator{A, K}\n\nIterator of forward kmers. S signifies the type of the underlying sequence, and the eltype of the iterator is Kmer{A, K, N} with the appropriate N. The elements in a FwKmers{A, K, S}(s::S) correspond to all the Kmer{A, K} in s, in order. \n\nCan be constructed more conventiently with the constructors FwDNAMers{K}(s) and similar also for FwRNAMers and FwAAMers.\n\nExamples:\n\njulia> s = \"AGCGTATA\";\n\njulia> v = collect(FwDNAMers{3}(s));\n\njulia> v == [DNAKmer{3}(s[i:i+2]) for i in 1:length(s)-2]\ntrue\n\njulia> eltype(v), length(v)\n(Kmer{DNAAlphabet{2}, 3, 1}, 6)\n\njulia> collect(FwRNAMers{3}(rna\"UGCDUGAVC\"))\nERROR: cannot encode D in RNAAlphabet{2}\n\n\n\n\n\n","category":"type"},{"location":"iteration/#Kmers.FwDNAMers","page":"Iteration","title":"Kmers.FwDNAMers","text":"FwDNAMers{K, S}: Alias for FwKmers{DNAAlphabet{2}, K, S}\n\n\n\n\n\n","category":"type"},{"location":"iteration/#Kmers.FwRNAMers","page":"Iteration","title":"Kmers.FwRNAMers","text":"FwRNAMers{K, S}: Alias for FwKmers{RNAAlphabet{2}, K, S}\n\n\n\n\n\n","category":"type"},{"location":"iteration/#Kmers.FwAAMers","page":"Iteration","title":"Kmers.FwAAMers","text":"FwAAMers{K, S}: Alias for FwKmers{AminoAcidAlphabet, K, S}\n\n\n\n\n\n","category":"type"},{"location":"iteration/#FwRvIterator","page":"Iteration","title":"FwRvIterator","text":"","category":"section"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"This iterates over a nucleic acid sequence. For every kmer it encounters, it outputs the kmer and its reverse complement.","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"FwRvIterator","category":"page"},{"location":"iteration/#Kmers.FwRvIterator","page":"Iteration","title":"Kmers.FwRvIterator","text":"FwRvIterator{A <: NucleicAcidAlphabet, K, S}\n\nIterates 2-tuples of (forward, reverse_complement) of every kmer of type Kmer{A, K} from the underlying sequence, in order. S signifies the type of the underlying sequence. This is typically more efficient than iterating over a FwKmers and computing reverse_complement on every element.\n\nSee also: FwKmers, CanonicalKmers\n\nExamples:\n\njulia> collect(FwRvIterator{DNAAlphabet{4}, 3}(\"AGCGT\"))\n3-element Vector{Tuple{Mer{3, DNAAlphabet{4}, 1}, Mer{3, DNAAlphabet{4}, 1}}}:\n (AGC, GCT)\n (GCG, CGC)\n (CGT, ACG)\n\njulia> collect(FwRvIterator{DNAAlphabet{2}, 3}(\"AGNGT\"))\nERROR: cannot encode 0x4e (Char 'N') in DNAAlphabet{2}\n[...]\n\n\n\n\n\n","category":"type"},{"location":"iteration/#CanonicalKmers","page":"Iteration","title":"CanonicalKmers","text":"","category":"section"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"This iterator is similar to FwKmers, however, for each Kmer encountered, it returns the canonical kmer.","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"The canonical kmer is defined as the lexographically smaller of a kmer and its reverse complement. That is, if FwKmers would iterate TCAC, then CanonicalKmers would return GTGA, as this is the reverse complement of TCAC, and is before TCAC in the alphabet.","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"CanonicalKmers is useful for summarizing the kmer composition of sequences whose strandedness is unknown.","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"CanonicalKmers\nCanonicalDNAMers\nCanonicalRNAMers","category":"page"},{"location":"iteration/#Kmers.CanonicalKmers","page":"Iteration","title":"Kmers.CanonicalKmers","text":"CanonicalKmers{A <: NucleicAcidAlphabet, K, S} <: AbstractKmerIterator{A, K}\n\nIterator of canonical nucleic acid kmers. The result of this iterator is equivalent to calling canonical on each value of a FwKmers iterator, but may be more efficient.\n\nnote: Note\nWhen counting small kmers, it may be more efficient to count FwKmers, then call canonical only once per unique kmer.\n\nCan be constructed more conventiently with the constructors CanonicalDNAMers{K}(s) CanonicalRNAMers{K}(s)\n\nExamples:\n\njulia> collect(CanonicalRNAMers{3}(\"AGCGA\"))\n3-element Vector{Kmer{RNAAlphabet{2}, 3, 1}}:\n AGC\n CGC\n CGA\n\n\n\n\n\n","category":"type"},{"location":"iteration/#Kmers.CanonicalDNAMers","page":"Iteration","title":"Kmers.CanonicalDNAMers","text":"CanonicalDNAMers{K, S}: Alias for CanonicalKmers{DNAAlphabet{2}, K, S}\n\n\n\n\n\n","category":"type"},{"location":"iteration/#Kmers.CanonicalRNAMers","page":"Iteration","title":"Kmers.CanonicalRNAMers","text":"CanonicalRNAMers{K, S}: Alias for CanonicalKmers{RNAAlphabet{2}, K, S}\n\n\n\n\n\n","category":"type"},{"location":"iteration/#UnambiguousKmers","page":"Iteration","title":"UnambiguousKmers","text":"","category":"section"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"UnambiguousKmers iterates unambiguous nucleotides (that is, kmers of the alphabets DNAAlphabet{2} or RNAAlphabet{2}). Any kmers containing ambiguous nucleotides such as W or N are skipped.","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"UnambiguousKmers\nUnambiguousDNAMers\nUnambiguousRNAMers","category":"page"},{"location":"iteration/#Kmers.UnambiguousKmers","page":"Iteration","title":"Kmers.UnambiguousKmers","text":"UnambiguousKmers{A <: TwoBit, K, S}\n\nIterator of (kmer, index), where kmer are 2-bit nucleic acid kmers in the underlying sequence, and index::Int the starting position of the kmer in the sequence. The extracted kmers differ from those of FwKmers in that any kmers containing ambiguous nucleotides are skipped, whereas using FwKmers, encountering unambiguous nucleotides result in an error.\n\nThis iterator can be constructed more conventiently with the constructors UnambiguousDNAMers{K}(s) and UnambiguousRNAMers{K}(s).\n\nnote: Note\nTo obtain canonical unambiguous kmers, simply call canonical on each kmer output by UnambiguousKmers.\n\nExamples:\n\njulia> it = UnambiguousRNAMers{4}(dna\"TGAGCWKCATC\");\n\njulia> collect(it)\n3-element Vector{Tuple{Kmer{RNAAlphabet{2}, 4, 1}, Int64}}:\n (UGAG, 1)\n (GAGC, 2)\n (CAUC, 8)\n\n\n\n\n\n","category":"type"},{"location":"iteration/#Kmers.UnambiguousDNAMers","page":"Iteration","title":"Kmers.UnambiguousDNAMers","text":"UnambiguousDNAMers{K, S}: Alias for UnambiguousKmers{DNAAlphabet{2}, K, S}\n\n\n\n\n\n","category":"type"},{"location":"iteration/#Kmers.UnambiguousRNAMers","page":"Iteration","title":"Kmers.UnambiguousRNAMers","text":"UnambiguousRNAMers{K, S}: Alias for UnambiguousKmers{RNAAlphabet{2}, K, S}\n\n\n\n\n\n","category":"type"},{"location":"iteration/#SpacedKmers","page":"Iteration","title":"SpacedKmers","text":"","category":"section"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"The SpacedKmers iterator iterates kmers with a fixed step size between k-mers. For example, for a K of 4, and a step size of 3, the output kmers would overlap with a single nucleotide, like so:","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"seq: TGATGCGTAGTG\n     TGCT\n        TGCG\n           GTAG","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"Hence, if FwKmers are analogous to UnitRange, SpacedKmers is analogous to StepRange.","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"SpacedKmers\nSpacedDNAMers\nSpacedRNAMers\nSpacedAAMers","category":"page"},{"location":"iteration/#Kmers.SpacedKmers","page":"Iteration","title":"Kmers.SpacedKmers","text":"SpacedKmers{A <: Alphabet, K, J, S} <: AbstractKmerIterator{A, K}\n\nIterator of kmers with step size. J signifies the step size, S the type of the underlying sequence, and the eltype of the iterator is Kmer{A, K, N} with the appropriate N.\n\nFor example, a SpacedKmers{AminoAcidAlphabet, 3, 5, Vector{UInt8}} sampling over seq::Vector{UInt8} will sample all kmers corresponding to seq[1:3], seq[6:8], seq[11:13] etc.\n\nSee also: each_codon, FwKmers\n\nExamples:\n\njulia> collect(SpacedDNAMers{3, 2}(\"AGCGTATA\"))\n3-element Vector{Kmer{DNAAlphabet{2}, 3, 1}}:\n AGC\n CGT\n TAT\n\n\n\n\n\n","category":"type"},{"location":"iteration/#Kmers.SpacedDNAMers","page":"Iteration","title":"Kmers.SpacedDNAMers","text":"SpacedDNAMers{K, J, S}: Alias for SpacedKmers{DNAAlphabet{2}, K, J, S}\n\n\n\n\n\n","category":"type"},{"location":"iteration/#Kmers.SpacedRNAMers","page":"Iteration","title":"Kmers.SpacedRNAMers","text":"SpacedRNAMers{K, J, S}: Alias for SpacedKmers{RNAAlphabet{2}, K, J, S}\n\n\n\n\n\n","category":"type"},{"location":"iteration/#Kmers.SpacedAAMers","page":"Iteration","title":"Kmers.SpacedAAMers","text":"SpacedAAMers{K, J, S}: Alias for SpacedKmers{AminoAcidAlphabet, K, J, S}\n\n\n\n\n\n","category":"type"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"The convenience functions each_codon return SpacedKmers with a K value of 3 and step size of 3:","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"each_codon","category":"page"},{"location":"iteration/#Kmers.each_codon","page":"Iteration","title":"Kmers.each_codon","text":"each_codon(s::BioSequence{<:Union{DNAAlphabet, RNAAlphabet}})\neach_codon(::Type{<:Union{DNA, RNA}}, s)\n\nConstruct an iterator of nucleotide 3-mers with step size 3 from s. The sequence s may be an RNA or DNA biosequence, in which case the element type is inferred, or the element type may be specified explicitly, in which case s may be a byte-like sequence such as a String or Vector{UInt8}.\n\nThis function returns SpacedKmers iterator.\n\nSee also: SpacedKmers\n\nExamples:\n\njulia> collect(each_codon(DNA, \"TGACGATCGAC\"))\n3-element Vector{Kmer{DNAAlphabet{2}, 3, 1}}:\n TGA\n CGA\n TCG\n\n\n\n\n\n","category":"function"},{"location":"iteration/#The-AbstractKmerIterator-interface","page":"Iteration","title":"The AbstractKmerIterator interface","text":"","category":"section"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"It's very likely that users of Kmers.jl need to implement their own custom kmer iterators, in which case they should subtype AbstractKmerIterator.","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"AbstractKmerIterator","category":"page"},{"location":"iteration/#Kmers.AbstractKmerIterator","page":"Iteration","title":"Kmers.AbstractKmerIterator","text":"AbstractKmerIterator{A <: Alphabet, K}\n\nAbstract type for kmer iterators. The element type is Kmer{A, K, N}, with the appropriately derived N.\n\nFunctions to implement:\n\nBase.iterate\nBase.length or Base.IteratorSize if not HasLength\n\n\n\n\n\n","category":"type"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"At the moment, there is no real interface implemented for this abstract type, other than that AbstractKmerIterator{A, K} needs to iterate Kmer{A, K}.","category":"page"},{"location":"hashing/","page":"Hashing","title":"Hashing","text":"CurrentModule = Kmers\nDocTestSetup = quote\n    using BioSequences\n    using Test\n    using Kmers\nend","category":"page"},{"location":"hashing/","page":"Hashing","title":"Hashing","text":"warning: Warning\nThe value of hashes are guaranteed to be reproducible for a given version of Kmers.jl and Julia, but may change in new minor versions of Julia or Kmers.jl","category":"page"},{"location":"hashing/#Hashing","page":"Hashing","title":"Hashing","text":"","category":"section"},{"location":"hashing/","page":"Hashing","title":"Hashing","text":"Kmers.jl implements Base.hash, yielding a UInt value:","category":"page"},{"location":"hashing/","page":"Hashing","title":"Hashing","text":"julia> hash(mer\"UGCUGUAC\"r)\n0xe5057d38c8907b22","category":"page"},{"location":"hashing/","page":"Hashing","title":"Hashing","text":"The implementation of Base.hash for kmers strikes a compromise between providing a high-quality (non-cryptographic) hash, while being reasonably fast. While hash collisions can easily be found, they are unlikely to occur at random. When kmers are of the same (or compatible) alphabets, different kmers hash to different values (not counting the occational hash collision), even when they have the same underlying bitpattern:","category":"page"},{"location":"hashing/","page":"Hashing","title":"Hashing","text":"julia> using BioSequences: encoded_data\n\njulia> a = mer\"TAG\"d; b = mer\"AAAAAAATAG\"d;\n\njulia> encoded_data(a) === encoded_data(b)\ntrue\n\njulia> hash(a) == hash(b)\nfalse","category":"page"},{"location":"hashing/","page":"Hashing","title":"Hashing","text":"When they are of compatible alphabets, and have the same content, they hash to the same value. Currently, only DNA and RNA of the alphabets DNAAlphabet and RNAAlphabet are compatible:","category":"page"},{"location":"hashing/","page":"Hashing","title":"Hashing","text":"julia> a = mer\"UUGU\"r; b = mer\"TTGT\"d;\n\njulia> a == b # equal\ntrue\n\njulia> a === b # not egal\nfalse\n\njulia> hash(a) === hash(b)\ntrue","category":"page"},{"location":"hashing/","page":"Hashing","title":"Hashing","text":"For some applications, fast hashing is absolutely crucial. For these cases, Kmers.jl provides fx_hash, which trades off hash quality for speed:","category":"page"},{"location":"hashing/","page":"Hashing","title":"Hashing","text":"fx_hash","category":"page"},{"location":"hashing/#Kmers.fx_hash","page":"Hashing","title":"Kmers.fx_hash","text":"fx_hash(x, [h::UInt])::UInt\n\nAn implementation of FxHash. This hash function is extremely fast, but the hashes are of poor quality compared to Julia's default MurmurHash3. In particular:\n\nThe hash function does not have a good avalanche effect, e.g. the lower bits of the result depend only on the top few bits of the input\nThe bitpattern zero hashes to zero\n\nHowever, for many applications, FxHash is good enough, if the cost of the higher rate of hash collisions are offset by the faster speed.\n\nThe precise hash value of a given kmer is not guaranteed to be stable across minor releases of Kmers.jl, but is guaranteed to be stable across minor versions of Julia.\n\nExamples\n\njulia> x = fx_hash(mer\"KWQLDE\"a);\n\njulia> y = fx_hash(mer\"KWQLDE\"a, UInt(1));\n\njulia> x isa UInt\ntrue\n\njulia> x == y\nfalse\n\n\n\n\n\n","category":"function"},{"location":"translation/","page":"Translation","title":"Translation","text":"CurrentModule = Kmers\nDocTestSetup = quote\n    using BioSequences\n    using Test\n    using Kmers\nend","category":"page"},{"location":"translation/#Translation","page":"Translation","title":"Translation","text":"","category":"section"},{"location":"translation/","page":"Translation","title":"Translation","text":"Kmers can be translated using the translate function exported by BioSequences:","category":"page"},{"location":"translation/","page":"Translation","title":"Translation","text":"julia> translate(mer\"UGCUUGAUC\"r)\nAminoAcid 3-mer:\nCLI","category":"page"},{"location":"translation/","page":"Translation","title":"Translation","text":"Since Kmers are immutable, the in-place translate! function is not implemented for Kmers. Also, remember that Kmers are only efficient when short (at most a few hundred symbols). Hence, entire exons or genes should probably not ever be represented by a Kmer, but rather as a LongSequence or LongSubSeq from BioSequences.jl.","category":"page"},{"location":"translation/#Reverse-translation","page":"Translation","title":"Reverse translation","text":"","category":"section"},{"location":"translation/","page":"Translation","title":"Translation","text":"Kmers.jl implements reverse translation, which maps an amino acid sequence to one or more RNA sequences. While this process doesn't occur naturally (as far as we know), it is still useful for some analyses.","category":"page"},{"location":"translation/","page":"Translation","title":"Translation","text":"Since genetic codes are degenerate, i.e. multiple codons code for the same amino acid, reverse translating a sequence does not return a nucleic acid sequence, but a vector of CodonSet:","category":"page"},{"location":"translation/","page":"Translation","title":"Translation","text":"reverse_translate\nCodonSet","category":"page"},{"location":"translation/#Kmers.reverse_translate","page":"Translation","title":"Kmers.reverse_translate","text":"reverse_translate(s::Union{AminoAcid, AASeq}, code=rev_standard_genetic_code)\n\nReverse-translates sequence or amino acid s under code::ReverseGeneticCode If s is an AminoAcid, return a CodonSet. If s is an AASeq, return Vector{CodonSet}.\n\nExamples\n\njulia> reverse_translate(AA_W)\nCodonSet with 1 element:\n  UGG\n\njulia> v = reverse_translate(aa\"MMLVQ\");\n\njulia> typeof(v)\nVector{CodonSet} (alias for Array{CodonSet, 1})\n\njulia> v[4]\nCodonSet with 4 elements:\n  GUA\n  GUC\n  GUG\n  GUU\n\nSee also: reverse_translate!, ReverseGeneticCode\n\n\n\n\n\n","category":"function"},{"location":"translation/#Kmers.CodonSet","page":"Translation","title":"Kmers.CodonSet","text":"CodonSet <: AbstractSet{RNACodon}\n\nA small, immutable set of RNACodon.\n\nCreate an empty set using CodonSet(), or from an iterable of RNACodon using CodonSet(itr). Because CodonSet is immutable, use push instead of push!, and use the non-mutating set operations union, setdiff, etc.\n\nExamples\n\njulia> v = (mer\"UAG\"r, mer\"GGA\"r, mer\"UUU\"r);\n\njulia> Set(CodonSet(v)) == Set(v)\ntrue\n\njulia> union(CodonSet(v), CodonSet([mer\"GAG\"r]))\nCodonSet with 4 elements:\n  GAG\n  GGA\n  UAG\n  UUU\n\n\n\n\n\n","category":"type"},{"location":"translation/","page":"Translation","title":"Translation","text":"CodonSet is an efficiently implemented AbstractSet{RNACodon} (and remember, RNACodon is an alias for RNAKmer{3, 1}).","category":"page"},{"location":"translation/","page":"Translation","title":"Translation","text":"To avoid allocating a new Vector, you can use reverse_translate!:","category":"page"},{"location":"translation/","page":"Translation","title":"Translation","text":"reverse_translate!","category":"page"},{"location":"translation/#Kmers.reverse_translate!","page":"Translation","title":"Kmers.reverse_translate!","text":"reverse_translate!(v::Vector{CodonSet}, s::AASeq, code=rev_standard_genetic_code) -> v\n\nReverse-translates s under the reverse genetic code code, putting the result in v.\n\nSee also: reverse_translate\n\nExamples:\n\njulia> v = CodonSet[];\n\njulia> reverse_translate!(v, aa\"KWCL\")\n4-element Vector{CodonSet}:\n CodonSet(0x0000000000000005)\n CodonSet(0x0400000000000000)\n CodonSet(0x0a00000000000000)\n CodonSet(0x50000000f0000000)\n\n\n\n\n\n","category":"function"},{"location":"translation/","page":"Translation","title":"Translation","text":"Both functions take a genetic code as a keyword argument of the type ReverseGeneticCode. This object determines the mapping from amino acid to CodonSet - by default the standard genetic code is used - this mapping is used by nearly all organisms.","category":"page"},{"location":"translation/","page":"Translation","title":"Translation","text":"Only the reverse standard genetic code is defined in Kmers.jl. To use another genetic code, build a ReverseGeneticCode object from an existing BioSequences.GeneticCode:","category":"page"},{"location":"translation/","page":"Translation","title":"Translation","text":"julia> code = BioSequences.pterobrachia_mitochondrial_genetic_code;\n\njulia> rv_code = ReverseGeneticCode(code);\n\njulia> seq = aa\"KWLP\";\n\njulia> codonsets = reverse_translate(seq, rv_code)\n4-element Vector{CodonSet}:\n CodonSet(0x0000000000000405)\n CodonSet(0x0500000000000000)\n CodonSet(0x50000000f0000000)\n CodonSet(0x0000000000f00000)\n\njulia> codonsets == reverse_translate(seq) # default standard code\nfalse","category":"page"},{"location":"translation/","page":"Translation","title":"Translation","text":"ReverseGeneticCode","category":"page"},{"location":"translation/#Kmers.ReverseGeneticCode","page":"Translation","title":"Kmers.ReverseGeneticCode","text":"ReverseGeneticCode <: AbstractDict{AminoAcid, CodonSet}\n\nA mapping from an amino acid aa to the CodonSet of all codons that translate to aa. Conceptually, the inverse of a BioSequences.GeneticCode. Used by reverse_translate.\n\nAA_Gap cannot be translated. Ambiguous amino acids translate to the union of what their constituent amino acids translate to. Pyrrolysine and selenocysteine translate to CodonSet containing UAG and UGA, respectively, whereas they are not translated to in most forward genetic codes. For these reasons, a the mapping through ReverseGeneticCode is not exactly inverse of the mapping through GeneticCode\n\nExamples\n\njulia> code = ReverseGeneticCode(BioSequences.candidate_division_sr1_genetic_code);\n\njulia> code[AA_E]\nCodonSet with 2 elements:\n  GAA\n  GAG\n\njulia> code[AA_Gap]\nERROR: Cannot reverse translate element: -\n[...]\n\nSee also: reverse_translate\n\n\n\n\n\n","category":"type"},{"location":"composition/","page":"Kmer composition","title":"Kmer composition","text":"CurrentModule = Kmers\nDocTestSetup = quote\n    using BioSequences\n    using Test\n    using Kmers\nend","category":"page"},{"location":"composition/#Kmer-composition","page":"Kmer composition","title":"Kmer composition","text":"","category":"section"},{"location":"composition/","page":"Kmer composition","title":"Kmer composition","text":"In metagenomics, sequences are often summarized by counting the occurrence of all k-mers of a given length in a sequence. For example, for K=4, there are 4^4 = 256 possible DNA 4-mers. If these counts are ordered, the composition can be represented by a length 256 vector.","category":"page"},{"location":"composition/","page":"Kmer composition","title":"Kmer composition","text":"Vector similarity operations (e.g. cosine distance) can then be used as an approximate proxy for phylogenetic distance.","category":"page"},{"location":"composition/","page":"Kmer composition","title":"Kmer composition","text":"In the example below, we exploit that:","category":"page"},{"location":"composition/","page":"Kmer composition","title":"Kmer composition","text":"A DNAKmer{4}'s data is a single-element tuple, which stores the sequence in the 8 lower bits.\nThe encoded_data function will return this tuple.","category":"page"},{"location":"composition/","page":"Kmer composition","title":"Kmer composition","text":"using BioSequences, FASTX, Kmers\nusing BioSequences: encoded_data\n\nfunction composition(record::FASTARecord)\n    counts = zeros(UInt32, 256)\n    frequencies = zeros(Float32, 256)\n    for kmer in FwDNAMers{4}(sequence(record))\n        @inbounds counts[only(encoded_data(kmer)) + 1] += 1\n    end\n    factor = 1 / sum(counts; init=zero(eltype(counts)))\n    for i in eachindex(counts, frequencies)\n        frequencies[i] = counts[i] * factor\n    end\n    frequencies\nend\n\n# Make two FASTA records - could be from an assembly\nrecs = [FASTARecord(string(i), randdnaseq(10000)) for i in \"AB\"]\n\n# Compute the 2-norm difference and verify it's in [0, 2].\n(comp_a, comp_b) = map(composition, recs)\ncomp_distance = sum((comp_a .- comp_b).^2)\nprintln(0.0 ≤ comp_distance ≤ 2.0)","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"CurrentModule = Kmers\nDocTestSetup = quote\n    using BioSequences\n    using Test\n    using Kmers\nend","category":"page"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/#Why-can-kmers-not-be-compared-to-biosequences?","page":"FAQ","title":"Why can kmers not be compared to biosequences?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"It may be surprising that kmers cannot be compared to other biosequences:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia> dna\"TAG\" == mer\"TAG\"d\nERROR: MethodError\n[...]","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In fact, this is implemented by a manually thrown MethodError; the generic case Base.:==(::BioSequence, ::BioSequence) is defined.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The reason for this is the consequence of the following limitations:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"isequal(x, y) implies hash(x) == hash(y)\nisequal(x, y) and x == y ought to be identical for well-defined elements (i.e. in the absence of missings and NaNs etc.)\nhash(::Kmer) must be absolutely maximally efficient","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If kmers were to be comparable to BioSequence, then the hashing of BioSequence should follow Kmer, which practically speaking would mean that all biosequences would need to be recoded to Kmers before hashing.","category":"page"},{"location":"faq/#Why-isn't-there-an-iterator-of-unambiguous,-canonical-kmers-or-spaced,-canonical-kmers?","page":"FAQ","title":"Why isn't there an iterator of unambiguous, canonical kmers or spaced, canonical kmers?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Any iterator of nucleotide kmers can be made into a canonical kmer iterator by simply calling canonical on its output kers.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The CanonicalKmers iterator is special cased, because with a step size of 1, it is generally faster to build the next kmer by storing both the reverse and forward kmer, then creating the next kmer by prepending/append the next symbol.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"However, with a larger step size, it becomes more efficient to build the forward kmer, then reverse-complement the whole kmer.","category":"page"},{"location":"faq/#Why-isn't-there-an-iterator-of-skipmers/minimizers/k-min-mers,-etc?","page":"FAQ","title":"Why isn't there an iterator of skipmers/minimizers/k-min-mers, etc?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The concept of kmers have turned out to be remarkably flexible and useful in bioinformatics, and have spawned a neverending stream of variations. We simply can't implement them all.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"However, see the section Building kmer replacements on how to implement them as a user of Kmers.jl yourself.","category":"page"},{"location":"#Kmers.jl","page":"Home","title":"Kmers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kmers.jl provides the Kmer <: BioSequence type which implement the concept of a k-mer, a biological sequence of exactly length k.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compared to other BioSequences, Kmers are characterized by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Being immutable bitstypes\nBeing parameterized by its length, such that the length can be known at compile time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When kmers are short, and their length is known at compile time, these characteristics allow k-mers to be stack allocated, or stored in registers, allowing for much more efficient computation than arbitrary-length sequences.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Conceptually, one may use the following analogy:","category":"page"},{"location":"","page":"Home","title":"Home","text":"BioSequence is like AbstractVector\nLongSequence is like Vector\nKmer is like SVector from StaticArrays","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kmers.jl is tightly coupled to the BioSequences.jl package, and relies on its internals. Hence, you should expect strict compat bounds on BioSequences.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nKmers are parameterized by their length. That means any operation on Kmers that change their length, such as push, pop, slicing, or masking (logical indexing) will be type unstable and hence slow and memory inefficient, unless you write your code in such as way that the compiler can use constant folding.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kmers.jl is intended for high-performance computing. If you do not need the extra performance that register-stored sequences provide, you might consider using LongSequence from BioSequences.jl instead","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install BioSequences from the julia REPL. Press ] to enter pkg mode, and enter the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Kmers","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are interested in the cutting edge of development, please check out the master branch to try new features before release.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Take a look at the contributing files detailed contributor and maintainer guidelines, and code of conduct.","category":"page"},{"location":"#Questions?","page":"Home","title":"Questions?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have a question about contributing or using BioJulia software, come on over and chat to us on the Julia Slack workspace, or you can try the Bio category of the Julia discourse site.","category":"page"}]
}
